/**
 * DevSecOps Pipeline for easybuggy
 *
 * Features:
 * - Ephemeral Docker agents (no builds on Jenkins controller)
 * - Docker-in-Docker for image builds via mounted socket
 * - All security scan results archived as artifacts
 * - OWASP ZAP DAST scanning
 * - Parallel execution of independent stages
 *
 * Security Tools:
 * - SonarQube (SAST)
 * - OWASP Dependency-Check (SCA)
 * - Snyk (SCA + Container)
 * - Checkov (IaC)
 * - OWASP ZAP (DAST)
 */

pipeline {
    // Use Docker Cloud agent provisioned by Jenkins
    // The 'devsecops-agent' label matches the Docker Cloud template
    agent {
        label 'devsecops-agent'
    }

    options {
        // Retain artifacts for last 10 builds
        buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '10'))
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
        disableConcurrentBuilds()
    }

    environment {
        SONAR_HOST_URL = 'http://sonarqube:9000'
        // Registry URL for Docker daemon operations (build/push)
        // Uses localhost:5050 which maps to registry:5000 and is in Docker's insecure registries
        REGISTRY_URL = 'localhost:5050'
        DOCKER_IMAGE = 'easybuggy'
        ZAP_HOST = 'http://zap:8090'
        ZAP_TIMEOUT_MINUTES = '20'
        REPORTS_DIR = 'security-reports'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                // Create reports directory
                sh "mkdir -p ${REPORTS_DIR}"
            }
        }

        stage('Build and Test') {
            steps {
                sh 'mvn -Dmaven.test.failure.ignore clean verify'
            }
            post {
                always {
                    junit testResults: '**/target/surefire-reports/*.xml', allowEmptyResults: true
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withCredentials([string(credentialsId: 'SONAR_TOKEN', variable: 'SONAR_TOKEN')]) {
                    sh '''
                        mvn org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
                            -Dsonar.token=$SONAR_TOKEN \
                            -Dsonar.projectKey=easybuggy \
                            -Dsonar.host.url=${SONAR_HOST_URL} || true
                    '''
                    // Export SonarQube results via API (best-effort)
                    sh '''
                        sleep 10  # Wait for analysis to complete
                        curl -s -u "$SONAR_TOKEN:" \
                            "${SONAR_HOST_URL}/api/issues/search?projectKeys=easybuggy&resolved=false" \
                            -o ${REPORTS_DIR}/sonar-report.json || true
                    '''
                }
            }
        }

        stage('OWASP Dependency Check') {
            steps {
                script {
                    def nvdApiKeyExists = false
                    try {
                        withCredentials([string(credentialsId: 'NVD_API_KEY', variable: 'NVD_KEY')]) {
                            nvdApiKeyExists = true
                        }
                    } catch (Exception e) {
                        echo "NVD_API_KEY credential not found. Running with cached data only."
                    }

                    if (nvdApiKeyExists) {
                        withCredentials([string(credentialsId: 'NVD_API_KEY', variable: 'NVD_KEY')]) {
                            sh '''
                                mvn org.owasp:dependency-check-maven:check \
                                    -DfailBuildOnCVSS=11 \
                                    -Dformat=ALL \
                                    -DnvdApiKey=$NVD_KEY \
                                    -DnvdApiDelay=6000 || true
                            '''
                        }
                    } else {
                        sh '''
                            mvn org.owasp:dependency-check-maven:check \
                                -DfailBuildOnCVSS=11 \
                                -Dformat=ALL \
                                -DautoUpdate=false || true
                        '''
                    }
                }
                // Copy report to reports directory
                sh 'cp target/dependency-check-report.xml ${REPORTS_DIR}/ || true'
                sh 'cp target/dependency-check-report.json ${REPORTS_DIR}/ || true'
            }
            post {
                always {
                    dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
                }
            }
        }

        stage('Parallel Security Scans') {
            parallel {
                stage('Snyk SCA') {
                    steps {
                        withCredentials([string(credentialsId: 'SNYK_TOKEN', variable: 'SNYK_TOKEN')]) {
                            sh '''
                                snyk auth $SNYK_TOKEN
                                snyk test --json --severity-threshold=high \
                                    > ${REPORTS_DIR}/snyk-sca-report.json || true
                            '''
                        }
                    }
                }

                stage('Checkov IaC') {
                    steps {
                        sh '''
                            checkov -f main.tf \
                                --output json \
                                --soft-fail \
                                > ${REPORTS_DIR}/checkov-report.json || true
                        '''
                    }
                }
            }
        }

        stage('Build and Push Image') {
            steps {
                // Build and push Docker image using buildx
                // The agent has Docker socket access and buildx plugin installed
                sh '''
                    # Build and push the Docker image using buildx
                    # --push flag builds and pushes in one step
                    # --provenance=false avoids attestation issues with insecure registries
                    docker buildx build \
                        -t ${REGISTRY_URL}/${DOCKER_IMAGE}:${BUILD_NUMBER} \
                        -t ${REGISTRY_URL}/${DOCKER_IMAGE}:latest \
                        --push \
                        --provenance=false \
                        .
                '''
            }
        }

        stage('Snyk Container Scan') {
            steps {
                withCredentials([string(credentialsId: 'SNYK_TOKEN', variable: 'SNYK_TOKEN')]) {
                    sh '''
                        snyk auth $SNYK_TOKEN
                        # Scan the image from local registry (use host-accessible URL)
                        snyk container test ${REGISTRY_URL}/${DOCKER_IMAGE}:${BUILD_NUMBER} \
                            --json \
                            --severity-threshold=high \
                            > ${REPORTS_DIR}/snyk-container-report.json || true
                    '''
                }
            }
        }

        stage('DAST with OWASP ZAP') {
            steps {
                script {
                    // Start easybuggy container for DAST scanning
                    def appContainerId = ''
                    try {
                        // Pull and run the built image (use host-accessible registry URL for docker commands)
                        sh """
                            # Pull image from local registry
                            docker pull ${REGISTRY_URL}/${DOCKER_IMAGE}:${BUILD_NUMBER}

                            # Run easybuggy app on the same network as this agent
                            # The container name will be used as the hostname for network access
                            docker run -d --name easybuggy-dast-${BUILD_NUMBER} \
                                --network docker_devsecops-network \
                                -p 18080:8080 \
                                ${REGISTRY_URL}/${DOCKER_IMAGE}:${BUILD_NUMBER}

                            # Debug: Show container status
                            echo "=== Container status ==="
                            docker ps -a | grep easybuggy-dast-${BUILD_NUMBER} || true

                            # Debug: Show container logs (first 50 lines)
                            echo "=== Container logs ==="
                            sleep 5
                            docker logs easybuggy-dast-${BUILD_NUMBER} 2>&1 | head -50 || true

                            # Debug: Show network info
                            echo "=== Network info ==="
                            docker inspect easybuggy-dast-${BUILD_NUMBER} --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' || true
                        """

                        appContainerId = "easybuggy-dast-${BUILD_NUMBER}"

                        // Wait for app to be ready
                        // NOTE: Using double quotes (""") so BUILD_NUMBER is interpolated by Jenkins
                        // Dollar signs for shell variables (like $i) must be escaped as \$
                        sh """
                            echo "Waiting for easybuggy to start..."

                            # Get the container's IP address for direct access
                            CONTAINER_IP=\$(docker inspect easybuggy-dast-${BUILD_NUMBER} --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
                            echo "Container IP: \$CONTAINER_IP"

                            for i in \$(seq 1 30); do
                                # Try connecting by IP address (more reliable than DNS in some Docker setups)
                                if curl -s http://\$CONTAINER_IP:8080 > /dev/null 2>&1; then
                                    echo "easybuggy is ready at IP \$CONTAINER_IP!"
                                    break
                                fi
                                echo "Attempt \$i: waiting..."
                                sleep 5
                            done

                            # Verify the app is actually reachable before proceeding
                            if ! curl -s http://\$CONTAINER_IP:8080 > /dev/null 2>&1; then
                                echo "ERROR: easybuggy app is not reachable after 30 attempts"
                                echo "=== Final container logs ==="
                                docker logs easybuggy-dast-${BUILD_NUMBER} 2>&1 | tail -100 || true
                                exit 1
                            fi

                            # Store the IP for use in ZAP scan (export doesn't work across sh blocks, use file)
                            echo "\$CONTAINER_IP" > /tmp/easybuggy_ip_${BUILD_NUMBER}
                        """

                        // Run ZAP full active scan
                        // Use the container IP address for ZAP to reach the app
                        sh """
                            echo "Starting OWASP ZAP full active scan..."

                            # Read the container IP that was saved in the previous step
                            CONTAINER_IP=\$(cat /tmp/easybuggy_ip_${BUILD_NUMBER})
                            TARGET_URL="http://\$CONTAINER_IP:8080"
                            echo "Target URL for ZAP: \$TARGET_URL"

                            # Start spider scan using IP address
                            echo "Starting spider scan..."
                            curl -s "${ZAP_HOST}/JSON/spider/action/scan/?url=\$TARGET_URL&recurse=true"

                            # Wait for spider to complete
                            while [ \$(curl -s "${ZAP_HOST}/JSON/spider/view/status/" | jq -r '.status') != "100" ]; do
                                echo "Spider progress: \$(curl -s "${ZAP_HOST}/JSON/spider/view/status/" | jq -r '.status')%"
                                sleep 10
                            done
                            echo "Spider scan complete"

                            # Start active scan using IP address
                            echo "Starting active scan..."
                            curl -s "${ZAP_HOST}/JSON/ascan/action/scan/?url=\$TARGET_URL&recurse=true"

                            # Wait for active scan to complete (with timeout)
                            TIMEOUT=\$(( ${ZAP_TIMEOUT_MINUTES} * 60 ))
                            ELAPSED=0
                            while [ \$(curl -s "${ZAP_HOST}/JSON/ascan/view/status/" | jq -r '.status') != "100" ] && [ \$ELAPSED -lt \$TIMEOUT ]; do
                                echo "Active scan progress: \$(curl -s "${ZAP_HOST}/JSON/ascan/view/status/" | jq -r '.status')%"
                                sleep 30
                                ELAPSED=\$((\$ELAPSED + 30))
                            done
                            echo "Active scan complete or timed out"

                            # Generate reports
                            curl -s "${ZAP_HOST}/JSON/core/view/alerts/?baseurl=\$TARGET_URL" \
                                > ${REPORTS_DIR}/zap-report.json

                            curl -s "${ZAP_HOST}/OTHER/core/other/htmlreport/" \
                                > ${REPORTS_DIR}/zap-report.html

                            echo "ZAP reports generated"

                            # Cleanup temp file
                            rm -f /tmp/easybuggy_ip_${BUILD_NUMBER}
                        """

                    } catch (Exception e) {
                        echo "DAST stage failed: ${e.message}"
                    } finally {
                        // Cleanup: stop and remove easybuggy container
                        sh """
                            docker stop easybuggy-dast-${BUILD_NUMBER} || true
                            docker rm easybuggy-dast-${BUILD_NUMBER} || true
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            // Archive all security reports
            archiveArtifacts artifacts: "${REPORTS_DIR}/**/*", allowEmptyArchive: true

            // Publish HTML reports if available
            publishHTML(target: [
                allowMissing: true,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: "${REPORTS_DIR}",
                reportFiles: 'zap-report.html',
                reportName: 'ZAP DAST Report'
            ])

            cleanWs()
        }
        success {
            echo 'DevSecOps Pipeline completed successfully!'
            echo "All security reports archived as artifacts"
        }
        failure {
            echo 'Pipeline failed! Check the logs and archived reports for details.'
        }
    }
}

